# indicate these are not file related, and instead are scripts
.PHONY: controller clean

# set up device specific params
DEVICE ?= hx1k
BRAM   ?= implicit
PICO   ?= 1
ifeq ($(DEVICE), hx1k)
NUM_BLOCKS := 16
PNR_PARAMS := --hx1k --package tq144
CLOCK_SPEED := 12_000_000
PCF_FILE := constraints/hx1k.pcf
DATA := build/data.hex
else ifeq ($(DEVICE), up5k)
NUM_BLOCKS := 30
PNR_PARAMS := --up5k --package sg48
CLOCK_SPEED := 48_000_000
USE_SPRAM := -D USE_SPRAM
DATA := build/data.hex build/spram_data.hex
ifeq ($(PICO), 1)
PCF_FILE := constraints/up5k_pico_ice.pcf
UF2_ARG := -DPICO_BOARD=pico_ice -DPICO_PLATFORM=rp2040
else ifeq ($(PICO), 2)
PCF_FILE := constraints/up5k_pico2_ice.pcf
UF2_ARG := -DPICO_BOARD=pico2_ice -DPICO_PLATFORM=rp2350-riscv
else
$(error Pico not supported. Use 1 or 2)
endif
else
$(error Device not supported. Use hx1k or up5k)
endif

# program the FPGA with the memory controller
# run the python code for interfacing with BRAM on the FPGA
.ONESHELL:
controller: build/controller.bin
	@if [ "$(DEVICE)" = "hx1k" ]; then \
		iceprog build/controller.bin; \
		python3 src_python/shell.py; \
	elif [ "$(DEVICE)" = "up5k" ]; then \
# TODO: probably a more elegant way of doing this
		cd rp_firmware
		mkdir -p build
		cd build/
		cmake .. $(UF2_ARG)
		make
		cp rp2_ice_bram_controller.uf2 ../../build/
		cd ../../
# TODO: use picotool to put the uf2 file on the pi?
		echo "Generated build/rp2_ice_bram_controller.uf2"
	fi

# submodules for our memory controller
HELPER_VERILOG := src_verilog/receiver.v src_verilog/transmiter.v src_verilog/controller.v src_verilog/spram.v
BRAM_INSTS := src_verilog/explicit_bram.v src_verilog/implicit_bram.v

build/controller.bin: build $(HELPER_VERILOG) $(BRAM_INSTS) src_verilog/integrated_memory_controller.v $(DATA) 
# synthesis
# -p : run the following yosys subcommands
# -q : only print warnings and errors
# yosys interprets the last verilog file listed as the top module$(USE_SPRAM)
	if [ "$(BRAM)" = "implicit" ]; then \
		yosys -q -D NUM_BLOCKS_PARAM=$(NUM_BLOCKS) -D CLOCK_SPEED=$(CLOCK_SPEED) $(USE_SPRAM) \
		-p 'synth_ice40 -json build/controller.json' \
		$(HELPER_VERILOG) src_verilog/implicit_bram.v src_verilog/integrated_memory_controller.v; \
	elif [ "$(BRAM)" = "explicit" ]; then \
		python3 src_python/generate_explicit_bram.py --n $(NUM_BLOCKS) --d $(DEVICE) --o build/controller_generated_rams.vh; \
		yosys -q -D NUM_BLOCKS_PARAM=$(NUM_BLOCKS) -D CLOCK_SPEED=$(CLOCK_SPEED) $(USE_SPRAM) \
		-D BRAM_INCLUDE_FILE="\"build/controller_generated_rams.vh\"" -p 'synth_ice40 -json build/controller.json' \
		$(HELPER_VERILOG) src_verilog/explicit_bram.v src_verilog/integrated_memory_controller.v; \
	fi

# place and route
# -q : only print warnings and errors
# --hx1k --package tq144 / --up5k --package sg48 : our device specs
# --asc : name of the asc file to generate
# --json : json file generated by synthesis
# --pcf : pin constraints file for i/o
	nextpnr-ice40 -q $(PNR_PARAMS) --asc build/controller.asc --json build/controller.json --pcf $(PCF_FILE)

# convert ASCII bitstream to binary
	icepack build/controller.asc build/controller.bin

build/data.hex:
	@if [ "$(BRAM)" = "implicit" ]; then \
		icebram -g -s 0 16 $$((256 * $(NUM_BLOCKS))) > build/data.hex; \
	elif [ "$(BRAM)" = "explicit" ]; then \
# each explicit bram block needs its only data file \
		mkdir -p build/data; \
		touch build/data.hex; \
		for i in `seq 0 $$(($(NUM_BLOCKS) - 1))`; do \
			icebram -g -s $$i 16 256 > build/data/$$i.hex; \
# concat all the files together so we have something in the same format as the implicit one \
			cat build/data/$$i.hex >> build/data.hex; \
		done; \
	fi

build/spram_data.hex:
	icebram -g -s 0 16 $$((4 * 16384)) > build/spram_data.hex

# make the build directory if it does not already exist
build:
	mkdir -p build

# remove all files from the build directory
clean:
	rm -rf build/*
	# rm -rf rp_firmware/build/*